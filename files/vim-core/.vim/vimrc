" Author: Matt Soucy

" {{{ vim settings
set laststatus=2
set tabstop=4
set shiftwidth=0 " Set it to the tabstop value
set number
if exists('&relativenumber')
    set relativenumber
endif
set ignorecase
set modeline
set nobackup
set noswapfile
set wrap
set hidden
set hlsearch
if exists('&cc')
    set cc=80,120
endif
set cursorline cursorcolumn
set shortmess+=I " Don't show the intro message
set splitbelow splitright " Make splits go southeast
if has('gui_running')
    set guioptions+=M
endif
if exists('&inccommand')
    set inccommand=split
endif
syntax on "Syntax highlighting
" }}}

" {{{ Plugins
" {{{ Plugin settings
let g:table_mode_corner = '|'
let g:vim_markdown_folding_disabled=1
let g:netrw_liststyle=3
let g:haskell_conceal_wide=1
let g:pandoc#syntax#codeblocks#embeds#langs = ['java', 'python', 'sh', 'dot', 'cpp', 'd']
" {{{ Clang-format
let g:clang_format#auto_format = 0
let g:clang_format#code_style = 'llvm'
let g:clang_format#style_options = {
            \ 'IndentWidth': 4,
            \ 'TabWidth': 4,
            \ 'UseTab': "Always",
            \ 'AlwaysBreakTemplateDeclarations': "true",
            \ 'ColumnLimit': 80
            \}
let g:clang_format#auto_formatexpr = 1
" }}}
" {{{ Neomake
let g:neomake_open_list=2
" }}}
" {{{ tmuxline
let g:tmuxline_powerline_separators = 0
let g:tmuxline_preset = {
            \'a'    : '#S',
            \'b'    : '#W',
            \'c'    : '#H',
            \'win'  : '#I | #W',
            \'cwin' : '#I | #W',
            \'y'    : '%a',
            \'z'    : '%R'}

" }}}

" }}}

" {{{ Load plugins
function! Cond(cond, ...)
    " Conditionally enable plugins for vim-plug
    let opts = get(a:000, 0, {})
    return a:cond ? opts : extend(opts, { 'on': [], 'for': [] })
endfunction

if !empty(globpath(&rtp, "autoload/plug.vim"))
    if has('nvim')
        " NeoVim wants to store them in $XDG_CONFIG_HOME, but we want to
        " share them between nvim and vim
        let g:plug_home = expand('~/.vim/plugged')
    endif
    call plug#begin()
    runtime! pluglists/*.vim
    call plug#end()
else
    filetype plugin indent on
    syntax on
endif

" }}}

" }}} Plugins

" {{{ Color
function! s:UseColors(...)
    for scheme in a:000
        if len(globpath(&rtp, 'colors/'.scheme.'.vim'))
            exec 'colorscheme '.scheme
            break
        endif
    endfor
endfunction

set background=dark
call s:UseColors('gruvbox', 'PaperColor', 'badwolf', 'desert')
hi clear Conceal " Causes weird color errors otherwise
" }}}

" {{{ Keybindings

function! RunMaker(...)
    if exists(':Neomake')
        :Neomake
    else
        :make | copen
    endif
endfunction

" Fix weird issues
noremap <F3> <Esc>:syntax sync fromstart<CR>
inoremap <F3> <C-o>:syntax sync fromstart<CR>

"Mapped some FUNCTION keys to be more useful
noremap <F8> :call RunMaker()<Return>
noremap <F10> :cprevious<Return>
noremap <F11> :cnext<Return>

" paste mode toggle (needed when using autoindent/smartindent)
noremap <F7> :set paste<CR>
noremap <F7> :set nopaste<CR>
inoremap <F6> <C-O>:set paste<CR>
inoremap <F8> <C-O>:set nopaste<CR>
set pastetoggle=<F12>

"This is a nice buffer switcher
nnoremap <F5> :buffers<CR>:buffer<Space>

inoremap jj <ESC>
nmap <silent> <Leader>/ :nohlsearch<CR>
nmap <silent> <Leader>l :lclose<CR>
nmap <silent> <Leader>r :so $MYVIMRC<CR>

" Move by row, not line
nnoremap j gj
nnoremap k gk
nnoremap gj j
nnoremap gk k

" Highlight line and column
nnoremap H :set cursorline! cursorcolumn!<CR>

cabbr <expr> %% expand('%:p:h')

if exists(":TagbarToggle")
    nmap <silent> <Leader>t :TagbarToggle<CR>
endif
if executable('ag')
    set grepprg=ag\ --column\ --nopager\ --nocolor\ --nogroup\ $*\ /dev/null"
elseif executable('ack')
    set grepprg=ack\ --column\ --nopager\ --nocolor\ --nogroup\ $*\ /dev/null"
endif
" }}}

" {{{ Completion
"Set a nice Omnifunc - <CTRL>X <CTRL>O
set ofu=syntaxcomplete#Complete

" Make vim popup behave more like an IDE POPUP
set completeopt=longest,menuone
" }}}

" {{{ Lightline controls
let g:lightline = {
            \ 'colorscheme': g:colors_name,
            \ 'active': {
            \   'left': [ [ 'mode', 'paste' ],
            \             [ 'readonly', 'modified', 'fugitive', 'filename' ]],
            \   'right': [ [ 'neomake', 'lineinfo' ],
            \              ['percent'],
            \              [ 'fileformat', 'fileencoding', 'filetype' ] ]
            \ },
            \ 'component_function': {
            \   'fugitive': 'LightlineFugitive',
            \   'modified': 'LightlineModified',
            \   'readonly': 'LightlineReadonly',
            \   'fileformat': 'LightlineFileformat',
            \   'filetype': 'LightlineFiletype',
            \   'fileencoding': 'LightlineFileencoding',
            \ },
            \ 'component_expand': {
            \   'neomake': 'neomake#statusline#LoclistStatus',
            \ },
            \ 'component_type': {
            \   'neomake': 'error',
            \ },
            \ }

function! LightlineModified()
    return &ft =~ 'help' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! LightlineReadonly()
    return &ft !~? 'help' && &readonly ? 'RO' : ''
endfunction

function! LightlineFileformat()
  return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! LightlineFiletype()
  return winwidth(0) > 70 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
endfunction

function! LightlineFileencoding()
  return winwidth(0) > 70 ? (&fenc !=# '' ? &fenc : &enc) : ''
endfunction

function! LightlineFugitive()
  try
    if &ft !~? 'vimfiler\|tagbar' && exists('*fugitive#head')
      let mark = 'âŽ‡'  " edit here for cool mark
      let branch = fugitive#head()
      return branch !=# '' ? mark.branch : ''
    endif
  catch
  endtry
  return ''
endfunction

let g:tagbar_status_func = 'TagbarStatusFunc'

function! TagbarStatusFunc(current, sort, fname, ...) abort
    let g:lightline.fname = a:fname
    return lightline#statusline(0)
endfunction
" }}}

" {{{ Custom term behavior
if &term =~ '^screen'
    " tmux will send xterm-style keys when its xterm-keys option is on
    execute "set <xUp>=\e[1;*A"
    execute "set <xDown>=\e[1;*B"
    execute "set <xRight>=\e[1;*C"
    execute "set <xLeft>=\e[1;*D"
endif
" }}}

if filereadable(glob("~/.vimrc.local"))
    source ~/.vimrc.local
endif

" vim: foldmethod=marker expandtab
